{"version":3,"sources":["../../src/errors.ts","../../src/utils.ts","../../src/journals/index.ts","../../src/accounts/index.ts","../../src/reports/index.ts","../../src/seed/index.ts"],"names":["ObjectId","TX_COLLECTION","ACCT_COLLECTION","isDebitNormal","JOURNAL_COLLECTION"],"mappings":"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","file":"index.mjs","sourcesContent":["export class AccountingError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'AccountingError';\n  }\n}\n\nexport class ValidationError extends AccountingError {\n  constructor(message: string) {\n    super(message);\n    this.name = 'ValidationError';\n  }\n}\n\nexport class AccountNotFoundError extends AccountingError {\n  constructor(key: string) {\n    super(`Account not found with key: ${key}`);\n    this.name = 'AccountNotFoundError';\n  }\n}\n\nexport class DoubleEntryError extends AccountingError {\n  constructor(message: string) {\n    super(message);\n    this.name = 'DoubleEntryError';\n  }\n}\n\nexport class DatabaseError extends AccountingError {\n  constructor(originalError: any) {\n    super(originalError.message || 'Database error occurred');\n    this.name = 'DatabaseError';\n    this.stack = originalError.stack;\n  }\n}\n","import { DatabaseError } from './errors';\nimport { AccountingDbContext } from './types';\nimport { ClientSession } from 'mongodb';\n\nexport const DEFAULT_CHR_STATUS = 'N';\n\nexport function withChrStatusFilter<T extends Record<string, any>>(filter?: T): T & { chrStatus: string } {\n  return { chrStatus: DEFAULT_CHR_STATUS, ...(filter || ({} as T)) };\n}\n\nexport function withChrStatusDocument<T extends Record<string, any>>(doc: T): T & { chrStatus: string } {\n  return { chrStatus: DEFAULT_CHR_STATUS, ...doc };\n}\n\n/**\n * Wraps an async operation to handle standard DB errors.\n */\nexport async function execute<T>(\n  operation: () => Promise<T>\n): Promise<T> {\n  try {\n    return await operation();\n  } catch (err: any) {\n    // If it's already a known error type, rethrow. Otherwise wrap in DatabaseError if it looks like a DB error\n    if (err.name === 'MongoError' || err.name === 'MongoServerError') {\n      throw new DatabaseError(err);\n    }\n    throw err;\n  }\n}\n\n/**\n * rounds a number to 2 decimal places to help with float precision comparison\n * (Though ideally we should use integer math)\n */\nexport function round(num: number): number {\n    return Math.round((num + Number.EPSILON) * 100) / 100;\n}\n\n/**\n * Returns options object with session if present in context\n */\nexport function sessionOptions(ctx: AccountingDbContext): { session?: ClientSession } {\n    return ctx.session ? { session: ctx.session } : {};\n}","import { ObjectId } from 'mongodb';\nimport {\n  AccountingDbContext,\n  PostJournalInput,\n  PostJournalResult,\n  Journal,\n  TransactionLine,\n  Account,\n} from '../types';\nimport { ValidationError, DoubleEntryError, AccountNotFoundError } from '../errors';\nimport { DEFAULT_CHR_STATUS, execute, round, withChrStatusDocument, withChrStatusFilter } from '../utils';\n\nconst JOURNAL_COLLECTION = 'acct_journals';\nconst TX_COLLECTION = 'acct_transactions';\nconst ACCT_COLLECTION = 'acct_accounts';\n\nexport interface VoidJournalResult {\n  journalsVoided: number;\n  transactionsVoided: number;\n}\n\nexport function postJournal(\n  data: PostJournalInput,\n  ctx: AccountingDbContext\n): Promise<PostJournalResult> {\n  return execute(async () => {\n    // 1. Basic Validation\n    if (!data.lines || data.lines.length < 2) {\n      throw new ValidationError('Journal must have at least two lines');\n    }\n    if (!data.datetime) throw new ValidationError('Date is required');\n    if (!data.memo) throw new ValidationError('Memo is required');\n\n    // 2. Compute Totals & Validate Amounts\n    let totalDebit = 0;\n    let totalCredit = 0;\n    const accountKeys = new Set<string>();\n\n    data.lines.forEach((line, idx) => {\n      const debit = line.debit || 0;\n      const credit = line.credit || 0;\n\n      if (debit < 0 || credit < 0) {\n        throw new ValidationError(`Line ${idx}: Amounts cannot be negative`);\n      }\n      if (debit === 0 && credit === 0) {\n        throw new ValidationError(`Line ${idx}: Line must have a non-zero debit or credit`);\n      }\n      // Optional: Strict separation\n      if (debit > 0 && credit > 0) {\n        throw new ValidationError(`Line ${idx}: Line cannot have both debit and credit`);\n      }\n\n      totalDebit += debit;\n      totalCredit += credit;\n      accountKeys.add(line.accountKey);\n    });\n\n    // 3. Double Entry Check\n    // Use rounding to handle floating point epsilon issues\n    if (round(totalDebit) !== round(totalCredit)) {\n      throw new DoubleEntryError(\n        `Journal is not balanced. Debit: ${totalDebit}, Credit: ${totalCredit}`\n      );\n    }\n\n    // 4. Validate Accounts Exist & Get Codes\n    const accounts = await ctx.db\n      .collection<Account>(ACCT_COLLECTION)\n      .find(withChrStatusFilter({ key: { $in: Array.from(accountKeys) } }), { session: ctx.session })\n      .toArray();\n\n    const accountMap = new Map<string, Account>();\n    accounts.forEach((a) => accountMap.set(a.key, a));\n\n    const missingKeys = Array.from(accountKeys).filter((k) => !accountMap.has(k));\n    if (missingKeys.length > 0) {\n      throw new AccountNotFoundError(missingKeys.join(', '));\n    }\n\n    // Check if accounts are active\n    const inactive = accounts.filter(a => !a.isActive);\n    if (inactive.length > 0) {\n        throw new ValidationError(`Cannot post to inactive accounts: ${inactive.map(a => a.key).join(', ')}`);\n    }\n\n    // 5. Prepare Documents\n    const now = new Date();\n    const journalId = new ObjectId();\n    \n    const journalDoc: Journal = withChrStatusDocument({\n      _id: journalId,\n      ...(data.extra || {}),\n      memo: data.memo,\n      datetime: data.datetime,\n      referenceType: data.referenceType,\n      referenceId: data.referenceId,\n      voided: false,\n      createdAt: now,\n      updatedAt: now,\n    });\n\n    const transactionDocs: TransactionLine[] = data.lines.map((line) => {\n      const account = accountMap.get(line.accountKey)!;\n      const extra = { ...(data.transactionExtra || {}), ...(line.extra || {}) };\n      return withChrStatusDocument({\n        _id: new ObjectId(),\n        ...extra,\n        journalId: journalId,\n        accountKey: line.accountKey,\n        accountCode: account.code, // Denormalized for reporting speed\n        debit: line.debit || 0,\n        credit: line.credit || 0,\n        meta: line.meta,\n        datetime: data.datetime,\n        voided: false,\n        createdAt: now,\n        updatedAt: now,\n      });\n    });\n\n    // 6. Insert (Atomic if session exists)\n    await ctx.db.collection<Journal>(JOURNAL_COLLECTION).insertOne(journalDoc, { session: ctx.session });\n    await ctx.db.collection<TransactionLine>(TX_COLLECTION).insertMany(transactionDocs, { session: ctx.session });\n\n    return {\n      journal: journalDoc,\n      transactions: transactionDocs,\n    };\n  });\n}\n\nexport function voidJournal(\n  journalId: string | ObjectId,\n  reason: string,\n  ctx: AccountingDbContext\n): Promise<boolean> {\n  return execute(async () => {\n    const jId = new ObjectId(journalId);\n    const updatedAt = new Date();\n\n    // Update Journal\n    const result = await ctx.db.collection<Journal>(JOURNAL_COLLECTION).findOneAndUpdate(\n      withChrStatusFilter({ _id: jId, voided: false }),\n      {\n        $set: {\n          voided: true,\n          chrStatus: 'D',\n          voidReason: reason,\n          updatedAt,\n        }\n      },\n      { session: ctx.session }\n    );\n\n    if (!result) {\n      throw new ValidationError(`Journal not found or already voided: ${journalId}`);\n    }\n\n    // Update Transactions\n    await ctx.db.collection<TransactionLine>(TX_COLLECTION).updateMany(\n      withChrStatusFilter({ journalId: jId }),\n      {\n        $set: {\n          voided: true,\n          chrStatus: 'D',\n          updatedAt,\n        }\n      },\n      { session: ctx.session }\n    );\n\n    return true;\n  });\n}\n\nexport function voidJournalsByIdentifier(\n  identifier: { journalId?: string | ObjectId; referenceId?: string; referenceType?: string },\n  reason: string,\n  ctx: AccountingDbContext\n): Promise<VoidJournalResult> {\n  return execute(async () => {\n    if (!identifier.journalId && !identifier.referenceId) {\n      throw new ValidationError('journalId or referenceId is required');\n    }\n\n    const journalFilter: Record<string, any> = { voided: false };\n\n    if (identifier.journalId) {\n      journalFilter._id = new ObjectId(identifier.journalId);\n    }\n\n    if (identifier.referenceId) {\n      journalFilter.referenceId = identifier.referenceId;\n      if (identifier.referenceType) journalFilter.referenceType = identifier.referenceType;\n    }\n\n    const journals = await ctx.db\n      .collection<Journal>(JOURNAL_COLLECTION)\n      .find(withChrStatusFilter(journalFilter), { session: ctx.session })\n      .toArray();\n\n    if (journals.length === 0) {\n      throw new ValidationError('Journal not found or already voided');\n    }\n\n    const journalIds = journals.map((j) => j._id);\n    const updatedAt = new Date();\n\n    const journalResult = await ctx.db.collection<Journal>(JOURNAL_COLLECTION).updateMany(\n      withChrStatusFilter({ _id: { $in: journalIds } }),\n      {\n        $set: {\n          voided: true,\n          chrStatus: 'D',\n          voidReason: reason,\n          updatedAt,\n        },\n      },\n      { session: ctx.session }\n    );\n\n    const txResult = await ctx.db.collection<TransactionLine>(TX_COLLECTION).updateMany(\n      withChrStatusFilter({ journalId: { $in: journalIds } }),\n      {\n        $set: {\n          voided: true,\n          chrStatus: 'D',\n          updatedAt,\n        },\n      },\n      { session: ctx.session }\n    );\n\n    return {\n      journalsVoided: journalResult.modifiedCount,\n      transactionsVoided: txResult.modifiedCount,\n    };\n  });\n}\n\nexport function getJournal(\n  journalId: string | ObjectId,\n  ctx: AccountingDbContext\n): Promise<PostJournalResult | null> {\n  return execute(async () => {\n    const jId = new ObjectId(journalId);\n    const chrStatusFilter = { chrStatus: { $in: [DEFAULT_CHR_STATUS, 'D'] } };\n\n    const journal = await ctx.db.collection<Journal>(JOURNAL_COLLECTION).findOne(\n      { ...chrStatusFilter, _id: jId },\n      { session: ctx.session }\n    );\n\n    if (!journal) return null;\n\n    const transactions = await ctx.db.collection<TransactionLine>(TX_COLLECTION)\n      .find({ ...chrStatusFilter, journalId: jId }, { session: ctx.session })\n      .toArray();\n\n    return { journal, transactions };\n  });\n}","import { ObjectId } from 'mongodb';\nimport {\n  Account,\n  AccountingDbContext,\n  CreateAccountInput,\n  UpdateAccountInput,\n  AccountSeed,\n  AccountHierarchyNode,\n  ApplyOpeningBalanceInput,\n  PostJournalResult,\n  Journal,\n} from '../types';\nimport { ValidationError, AccountNotFoundError } from '../errors';\nimport { execute, round, sessionOptions, withChrStatusDocument, withChrStatusFilter } from '../utils';\nimport { postJournal, voidJournal } from '../journals';\n\nconst COLLECTION = 'acct_accounts';\nconst OPENING_BALANCE_REFERENCE_TYPE = 'opening_balance';\nconst DEFAULT_OPENING_BALANCE_ACCOUNT: Omit<Account, '_id' | 'createdAt' | 'updatedAt'> = {\n    key: 'OPENING_BALANCE_EQUITY',\n    code: '3999',\n    name: 'Opening Balance Equity',\n    type: 'equity',\n    parentGroup: 'equity',\n    group: 'Opening Balance',\n    origin: 'dynamicSystem',\n    isActive: true,\n    extra: { system: true },\n    chrStatus: 'N'\n};\n\n// --- Private Helpers ---\n\nfunction validateAccountStructure(data: CreateAccountInput | AccountSeed) {\n  if (!data.key || !data.code || !data.name || !data.type || !data.parentGroup || !data.group) {\n    throw new ValidationError('Missing required account fields');\n  }\n\n  // Validate Code Prefix convention\n  const codeInt = parseInt(data.code, 10);\n  if (isNaN(codeInt)) throw new ValidationError('Account code must be numeric string');\n\n  // Simple convention check (customizable)\n  let validPrefix = false;\n  if (data.type === 'asset' && data.code.startsWith('1')) validPrefix = true;\n  else if (data.type === 'liability' && data.code.startsWith('2')) validPrefix = true;\n  else if (data.type === 'equity' && data.code.startsWith('3')) validPrefix = true;\n  else if (data.type === 'income' && data.code.startsWith('4')) validPrefix = true;\n  else if ((data.type === 'expense' || data.type === 'contra') && (data.code.startsWith('5') || data.code.startsWith('6'))) validPrefix = true;\n  \n  // Allow system seeded or specific overrides, but warn/error on obvious mismatches if strict\n  // For this library, we enforce specific parentGroup mapping\n  \n  if (data.type === 'asset' && data.parentGroup !== 'asset') throw new ValidationError('Asset type must have asset parentGroup');\n  if (data.type === 'liability' && data.parentGroup !== 'liability') throw new ValidationError('Liability type must have liability parentGroup');\n  if (data.type === 'equity' && data.parentGroup !== 'equity') throw new ValidationError('Equity type must have equity parentGroup');\n  if (data.type === 'income' && data.parentGroup !== 'income') throw new ValidationError('Income type must have income parentGroup');\n  if (data.type === 'expense' && data.parentGroup !== 'expense') throw new ValidationError('Expense type must have expense parentGroup');\n  if (data.type === 'contra' && !['asset', 'liability'].includes(data.parentGroup)) {\n    throw new ValidationError('Contra accounts must belong to asset or liability parentGroup');\n  }\n}\n\n/**\n * Validates that the parent exists and prevents circular dependencies.\n * @param ctx \n * @param accountKey The key of the account being updated/created\n * @param parentKey The key of the proposed parent\n */\nasync function validateParent(\n    ctx: AccountingDbContext,\n    accountKey: string,\n    parentKey?: string | null\n) {\n    if (!parentKey) return;\n    if (accountKey === parentKey) {\n        throw new ValidationError('Account cannot be its own parent');\n    }\n\n    // 1. Check if parent exists\n    const parent = await ctx.db\n        .collection<Account>(COLLECTION)\n        .findOne(withChrStatusFilter({ key: parentKey }), sessionOptions(ctx));\n    if (!parent) {\n        throw new ValidationError(`Parent account '${parentKey}' not found`);\n    }\n\n    // 2. Check for cycles (walking up the tree from the new parent)\n    // If we find the current accountKey in the ancestry of the new parent, it's a cycle.\n    let currentKey: string | null | undefined = parent.parentAccountKey;\n    const visited = new Set<string>([parentKey]);\n    \n    // Safety break to prevent infinite loops if db already has cycles\n    let depth = 0;\n    const MAX_DEPTH = 100;\n\n    while (currentKey) {\n        if (currentKey === accountKey) {\n            throw new ValidationError(`Circular dependency detected. Account '${accountKey}' is an ancestor of '${parentKey}'`);\n        }\n        if (visited.has(currentKey)) {\n            break; // Cycle in existing data, stop to avoid infinite loop\n        }\n        visited.add(currentKey);\n        \n        const node = await ctx.db.collection<Account>(COLLECTION).findOne(\n            withChrStatusFilter({ key: currentKey }),\n            { projection: { parentAccountKey: 1 }, ...sessionOptions(ctx) }\n        );\n        \n        if (!node) break;\n        currentKey = node.parentAccountKey;\n        \n        depth++;\n        if (depth > MAX_DEPTH) break;\n    }\n}\n\nfunction isDebitNormal(account: Account): boolean {\n    return (\n        account.parentGroup === 'asset' ||\n        account.parentGroup === 'expense' ||\n        (account.type === 'contra' && account.parentGroup === 'liability')\n    );\n}\n\nasync function ensureOpeningBalanceOffsetAccount(\n    ctx: AccountingDbContext,\n    offsetKey?: string\n): Promise<Account> {\n    const keyToLookup = offsetKey || DEFAULT_OPENING_BALANCE_ACCOUNT.key;\n    const existing = await ctx.db\n        .collection<Account>(COLLECTION)\n        .findOne(withChrStatusFilter({ key: keyToLookup }), sessionOptions(ctx));\n    if (existing) return existing;\n\n    if (offsetKey) {\n        throw new ValidationError(`Offset account '${offsetKey}' not found`);\n    }\n\n    const now = new Date();\n    const doc: Account = withChrStatusDocument({\n        _id: new ObjectId(),\n        ...DEFAULT_OPENING_BALANCE_ACCOUNT,\n        createdAt: now,\n        updatedAt: now,\n    });\n\n    await ctx.db.collection<Account>(COLLECTION).insertOne(doc, sessionOptions(ctx));\n    return doc;\n}\n\nasync function voidExistingOpeningBalance(\n    accountKey: string,\n    ctx: AccountingDbContext\n): Promise<void> {\n    const existing = await ctx.db.collection<Journal>('acct_journals').findOne(\n        withChrStatusFilter({\n            referenceType: OPENING_BALANCE_REFERENCE_TYPE,\n            referenceId: accountKey,\n            voided: false,\n        }),\n        sessionOptions(ctx)\n    );\n\n    if (existing) {\n        await voidJournal(existing._id, 'Updated opening balance', ctx);\n    }\n}\n\n// --- Public Functions ---\n\nexport function createAccount(\n  data: CreateAccountInput,\n  ctx: AccountingDbContext\n): Promise<Account> {\n  return execute(async () => {\n    if (!data) throw new ValidationError('Data object is required');\n    validateAccountStructure(data);\n\n    // Validate parent if provided (For creation, we only need to check existence, \n    // as the new account has no children yet, so it can't be an ancestor of the parent)\n    if (data.parentAccountKey) {\n        const parent = await ctx.db\n            .collection<Account>(COLLECTION)\n            .findOne(withChrStatusFilter({ key: data.parentAccountKey }), sessionOptions(ctx));\n        if (!parent) {\n            throw new ValidationError(`Parent account '${data.parentAccountKey}' not found`);\n        }\n    }\n\n    // Check uniqueness\n    const existing = await ctx.db.collection<Account>(COLLECTION).findOne(\n      withChrStatusFilter({ $or: [{ key: data.key }, { code: data.code }] }),\n      sessionOptions(ctx)\n    );\n\n    if (existing) {\n      throw new ValidationError(`Account with key '${data.key}' or code '${data.code}' already exists`);\n    }\n\n    const now = new Date();\n    const doc: Account = withChrStatusDocument({\n      _id: new ObjectId(),\n      ...data,\n      origin: data.origin as any, // Cast required due to Input logic omitting systemSeeded\n      parentAccountKey: data.parentAccountKey || null,\n      extra: data.extra || {}, // Default to empty object if not provided, ensuring consistency\n      isActive: true,\n      createdAt: now,\n      updatedAt: now,\n    });\n\n    await ctx.db.collection<Account>(COLLECTION).insertOne(doc, sessionOptions(ctx));\n    return doc;\n  });\n}\n\nexport function updateAccount(\n  data: UpdateAccountInput,\n  ctx: AccountingDbContext\n): Promise<Account> {\n  return execute(async () => {\n    if (!data) throw new ValidationError('Data object is required');\n    if (!data.key) throw new ValidationError('Account key is required for update');\n\n    const updateFields: Partial<Account> = { updatedAt: new Date() };\n    if (data.name !== undefined) updateFields.name = data.name;\n    if (data.group !== undefined) updateFields.group = data.group;\n    if (data.isActive !== undefined) updateFields.isActive = data.isActive;\n    if (data.extra !== undefined) updateFields.extra = data.extra;\n    \n    // Handle hierarchy update\n    if (data.parentAccountKey !== undefined) {\n        await validateParent(ctx, data.key, data.parentAccountKey);\n        updateFields.parentAccountKey = data.parentAccountKey;\n    }\n\n    const result = await ctx.db.collection<Account>(COLLECTION).findOneAndUpdate(\n      withChrStatusFilter({ key: data.key }),\n      { $set: updateFields },\n      { ...sessionOptions(ctx), returnDocument: 'after' }\n    );\n\n    if (!result) {\n      throw new AccountNotFoundError(data.key);\n    }\n\n    return result as Account;\n  });\n}\n\nexport function deactivateAccount(\n  key: string,\n  ctx: AccountingDbContext\n): Promise<Account> {\n  return updateAccount({ key, isActive: false }, ctx);\n}\n\nexport function getAccountByKey(\n  key: string,\n  ctx: AccountingDbContext\n): Promise<Account | null> {\n  return execute(async () => {\n    return ctx.db.collection<Account>(COLLECTION).findOne(withChrStatusFilter({ key }), sessionOptions(ctx));\n  });\n}\n\nexport function getAccountByCode(\n  code: string,\n  ctx: AccountingDbContext\n): Promise<Account | null> {\n  return execute(async () => {\n    return ctx.db.collection<Account>(COLLECTION).findOne(withChrStatusFilter({ code }), sessionOptions(ctx));\n  });\n}\n\nexport function listAccounts(\n  filter: Partial<Account> & { limit?: number; skip?: number },\n  ctx: AccountingDbContext\n): Promise<Account[]> {\n  return execute(async () => {\n    const { limit = 100, skip = 0, ...query } = filter;\n    return ctx.db.collection<Account>(COLLECTION)\n      .find(withChrStatusFilter(query), sessionOptions(ctx))\n      .skip(skip)\n      .limit(limit)\n      .toArray();\n  });\n}\n\nexport function applyOpeningBalance(\n    data: ApplyOpeningBalanceInput,\n    ctx: AccountingDbContext\n): Promise<PostJournalResult | null> {\n    return execute(async () => {\n        if (!data) throw new ValidationError('Data object is required');\n        if (data.amount === undefined || data.amount === null || Number.isNaN(data.amount)) {\n            throw new ValidationError('Opening balance amount is required');\n        }\n\n        const account = await ctx.db\n            .collection<Account>(COLLECTION)\n            .findOne(withChrStatusFilter({ key: data.accountKey }), sessionOptions(ctx));\n        if (!account) {\n            throw new AccountNotFoundError(data.accountKey);\n        }\n        if (!account.isActive) {\n            throw new ValidationError('Cannot set opening balance on inactive accounts');\n        }\n\n        // Opening balance should be unique per account. Voiding keeps audit trail while enabling updates.\n        await voidExistingOpeningBalance(data.accountKey, ctx);\n\n        const amount = round(data.amount);\n        if (amount === 0) return null; // Nothing to post after voiding previous opening entry\n\n        const offsetAccount = await ensureOpeningBalanceOffsetAccount(ctx, data.offsetAccountKey);\n        const debitNormal = isDebitNormal(account);\n        const absAmount = Math.abs(amount);\n\n        const accountDebit = amount > 0 ? (debitNormal ? absAmount : 0) : (debitNormal ? 0 : absAmount);\n        const accountCredit = amount > 0 ? (debitNormal ? 0 : absAmount) : (debitNormal ? absAmount : 0);\n\n        const memo = data.memo || `Opening balance for ${account.name}`;\n        const datetime = data.datetime || new Date();\n\n        return postJournal({\n            memo,\n            datetime,\n            referenceType: OPENING_BALANCE_REFERENCE_TYPE,\n            referenceId: account.key,\n            lines: [\n                {\n                    accountKey: account.key,\n                    debit: round(accountDebit),\n                    credit: round(accountCredit),\n                    meta: data.meta,\n                },\n                {\n                    accountKey: offsetAccount.key,\n                    debit: round(accountCredit),\n                    credit: round(accountDebit),\n                    meta: { ...(data.meta || {}), offsetFor: account.key },\n                },\n            ],\n        }, ctx);\n    });\n}\n\nexport function getAccountHierarchy(\n  ctx: AccountingDbContext\n): Promise<AccountHierarchyNode[]> {\n  return execute(async () => {\n    // 1. Fetch all accounts\n    const accounts = await ctx.db\n        .collection<Account>(COLLECTION)\n        .find(withChrStatusFilter({}), sessionOptions(ctx))\n        .toArray();\n    \n    // 2. Map to nodes\n    const accountMap = new Map<string, AccountHierarchyNode>();\n    accounts.forEach(acc => {\n        accountMap.set(acc.key, { ...acc, children: [] });\n    });\n\n    const roots: AccountHierarchyNode[] = [];\n\n    // 3. Assemble tree\n    accounts.forEach(acc => {\n        const node = accountMap.get(acc.key)!;\n        if (acc.parentAccountKey && accountMap.has(acc.parentAccountKey)) {\n            const parent = accountMap.get(acc.parentAccountKey)!;\n            parent.children.push(node);\n        } else {\n            roots.push(node);\n        }\n    });\n\n    return roots;\n  });\n}\n\nexport function getChartOfAccounts(\n    ctx: AccountingDbContext\n): Promise<AccountHierarchyNode[]> {\n    return getAccountHierarchy(ctx);\n}\n\nasync function findAccountByIdentifier(\n    identifier: string | ObjectId,\n    ctx: AccountingDbContext\n): Promise<Account> {\n    const query: any = { key: identifier };\n\n    if (identifier instanceof ObjectId || (typeof identifier === 'string' && ObjectId.isValid(identifier))) {\n        const _id = identifier instanceof ObjectId ? identifier : new ObjectId(identifier);\n        query.$or = [{ key: identifier }, { _id }];\n        delete query.key;\n    }\n\n    const account = await ctx.db\n        .collection<Account>(COLLECTION)\n        .findOne(withChrStatusFilter(query), sessionOptions(ctx));\n    if (!account) {\n        throw new AccountNotFoundError(typeof identifier === 'string' ? identifier : identifier.toHexString());\n    }\n\n    return account;\n}\n\nexport function getChildAccounts(\n    identifier: string | ObjectId,\n    ctx: AccountingDbContext\n): Promise<Account[]> {\n    return execute(async () => {\n        const account = await findAccountByIdentifier(identifier, ctx);\n        const accounts = await ctx.db\n            .collection<Account>(COLLECTION)\n            .find(withChrStatusFilter({}), sessionOptions(ctx))\n            .toArray();\n\n        const childrenMap = new Map<string, Account[]>();\n        accounts.forEach(acc => {\n            if (!acc.parentAccountKey) return;\n            const siblings = childrenMap.get(acc.parentAccountKey) || [];\n            siblings.push(acc);\n            childrenMap.set(acc.parentAccountKey, siblings);\n        });\n\n        const descendants: Account[] = [];\n        const stack: string[] = [account.key];\n\n        while (stack.length > 0) {\n            const currentKey = stack.pop()!;\n            const children = childrenMap.get(currentKey) || [];\n            children.forEach(child => {\n                descendants.push(child);\n                stack.push(child.key);\n            });\n        }\n\n        return descendants;\n    });\n}\n\nexport function getParentAccounts(\n    identifier: string | ObjectId,\n    ctx: AccountingDbContext\n): Promise<Account[]> {\n    return execute(async () => {\n        const accounts = await ctx.db\n            .collection<Account>(COLLECTION)\n            .find(withChrStatusFilter({}), sessionOptions(ctx))\n            .toArray();\n        const accountMap = new Map<string, Account>();\n        accounts.forEach(acc => accountMap.set(acc.key, acc));\n\n        const account = await findAccountByIdentifier(identifier, ctx);\n\n        const parents: Account[] = [];\n        let currentKey = account.parentAccountKey;\n\n        while (currentKey) {\n            const parent = accountMap.get(currentKey);\n            if (!parent) break;\n            parents.push(parent);\n            currentKey = parent.parentAccountKey || null;\n        }\n\n        return parents;\n    });\n}","import {\n    AccountingDbContext,\n    AccountBalanceResult,\n    AccountLedgerResult,\n    TrialBalanceResult,\n    ProfitAndLossResult,\n    BalanceSheetResult,\n    Account,\n    TransactionLine,\n    TrialBalanceLine\n  } from '../types';\n  import { execute, round, withChrStatusFilter } from '../utils';\n  \n  const TX_COLLECTION = 'acct_transactions';\n  const ACCT_COLLECTION = 'acct_accounts';\n  \n  // --- Helpers ---\n  \n  const getNetBalance = (debit: number, credit: number, type: string, parentGroup: string) => {\n      // Asset/Expense: Debit +\n      // Liab/Equity/Income: Credit +\n      const isDebitNormal = \n          parentGroup === 'asset' || \n          parentGroup === 'expense' || \n          (type === 'contra' && parentGroup === 'liability'); // Contra Liability is Debit normal\n      \n      if (isDebitNormal) return round(debit - credit);\n      return round(credit - debit);\n  };\n  \n  // --- Implementations ---\n  \n  export function getAccountBalance(\n    data: { accountKey: string; from?: Date; to?: Date; metaFilter?: Record<string, any> },\n    ctx: AccountingDbContext\n  ): Promise<AccountBalanceResult> {\n    return execute(async () => {\n      const match: any = withChrStatusFilter({\n          accountKey: data.accountKey,\n          voided: false\n      });\n      \n      if (data.from || data.to) {\n          match.datetime = {};\n          if (data.from) match.datetime.$gte = data.from;\n          if (data.to) match.datetime.$lte = data.to;\n      }\n      \n      if (data.metaFilter) {\n          for (const [k, v] of Object.entries(data.metaFilter)) {\n              match[`meta.${k}`] = v;\n          }\n      }\n  \n      const result = await ctx.db.collection<TransactionLine>(TX_COLLECTION).aggregate([\n          { $match: match },\n          { \n              $group: {\n                  _id: null,\n                  debit: { $sum: '$debit' },\n                  credit: { $sum: '$credit' }\n              }\n          }\n      ], { session: ctx.session }).toArray();\n  \n      if (result.length === 0) {\n          return { balance: 0, debit: 0, credit: 0 };\n      }\n  \n      const { debit, credit } = result[0];\n      \n      // Need account type to determine sign of balance\n      const account = await ctx.db.collection<Account>(ACCT_COLLECTION).findOne(\n          withChrStatusFilter({ key: data.accountKey }),\n          { projection: { type: 1, parentGroup: 1 }, session: ctx.session }\n      );\n      \n      if (!account) throw new Error(`Account ${data.accountKey} not found`);\n  \n      return {\n          debit: round(debit),\n          credit: round(credit),\n          balance: getNetBalance(debit, credit, account.type, account.parentGroup)\n      };\n    });\n  }\n  \n  export function getAccountLedger(\n    data: {\n      accountKey: string;\n      from?: Date;\n      to?: Date;\n      metaFilter?: Record<string, any>;\n      page?: number;\n      pageSize?: number;\n    },\n    ctx: AccountingDbContext\n  ): Promise<AccountLedgerResult> {\n    return execute(async () => {\n      const page = data.page || 1;\n      const pageSize = data.pageSize || 50;\n      const skip = (page - 1) * pageSize;\n  \n      // 1. Calculate Opening Balance (sum of everything BEFORE 'from')\n      let openingBalance = 0;\n      if (data.from) {\n          const preRes = await getAccountBalance({ \n              accountKey: data.accountKey, \n              to: new Date(data.from.getTime() - 1),\n              metaFilter: data.metaFilter \n          }, ctx);\n          openingBalance = preRes.balance;\n      }\n  \n      // 2. Query Items\n      const match: any = withChrStatusFilter({\n          accountKey: data.accountKey,\n          voided: false\n      });\n      if (data.from || data.to) {\n          match.datetime = {};\n          if (data.from) match.datetime.$gte = data.from;\n          if (data.to) match.datetime.$lte = data.to;\n      }\n      if (data.metaFilter) {\n        for (const [k, v] of Object.entries(data.metaFilter)) {\n            match[`meta.${k}`] = v;\n        }\n    }\n  \n      const items = await ctx.db.collection<TransactionLine>(TX_COLLECTION)\n          .find(match, { session: ctx.session })\n          .sort({ datetime: 1, _id: 1 })\n          .skip(skip)\n          .limit(pageSize)\n          .toArray();\n      \n      // Get account info for normal direction\n      const account = await ctx.db.collection<Account>(ACCT_COLLECTION).findOne(\n          withChrStatusFilter({ key: data.accountKey }),\n          { session: ctx.session }\n      );\n      if (!account) throw new Error(\"Account not found\");\n  \n      // 3. Compute Running Balance for the page\n      // Note: This calculates running balance RELATIVE to the page start + opening balance.\n      // Accurate running balance requires scanning from start, but for pagination, \n      // we assume the openingBalance covers previous pages/dates.\n      \n      let currentBalance = openingBalance;\n      const ledgerItems = items.map(item => {\n          const netChange = getNetBalance(item.debit, item.credit, account.type, account.parentGroup);\n          currentBalance = round(currentBalance + netChange);\n          return {\n              ...item,\n              runningBalance: currentBalance\n          };\n      });\n  \n      const totalCount = await ctx.db.collection<TransactionLine>(TX_COLLECTION).countDocuments(match, { session: ctx.session });\n  \n      return {\n          items: ledgerItems,\n          total: totalCount,\n          page,\n          pageSize\n      };\n    });\n  }\n  \n  export function getTrialBalance(\n    data: { from?: Date; to?: Date },\n    ctx: AccountingDbContext\n  ): Promise<TrialBalanceResult> {\n    return execute(async () => {\n      const match: any = withChrStatusFilter({ voided: false });\n      if (data.from || data.to) {\n          match.datetime = {};\n          if (data.from) match.datetime.$gte = data.from;\n          if (data.to) match.datetime.$lte = data.to;\n      }\n  \n      // Aggregate totals by account\n      const aggr = await ctx.db.collection<TransactionLine>(TX_COLLECTION).aggregate([\n          { $match: match },\n          { \n              $group: { \n                  _id: \"$accountKey\",\n                  totalDebit: { $sum: \"$debit\" },\n                  totalCredit: { $sum: \"$credit\" }\n              } \n          }\n      ], { session: ctx.session }).toArray();\n  \n      // Get all accounts to map details\n      const accounts = await ctx.db\n        .collection<Account>(ACCT_COLLECTION)\n        .find(withChrStatusFilter({}), { session: ctx.session })\n        .toArray();\n      const accountMap = new Map<string, Account>(accounts.map(a => [a.key, a]));\n  \n      const lines: TrialBalanceLine[] = [];\n      let grandTotalDebit = 0;\n      let grandTotalCredit = 0;\n  \n      for (const row of aggr) {\n          const acct = accountMap.get(row._id);\n          if (!acct) continue;\n  \n          const d = round(row.totalDebit);\n          const c = round(row.totalCredit);\n          grandTotalDebit += d;\n          grandTotalCredit += c;\n  \n          lines.push({\n              accountKey: acct.key,\n              accountCode: acct.code,\n              accountName: acct.name,\n              debit: d,\n              credit: c,\n              balance: getNetBalance(d, c, acct.type, acct.parentGroup)\n          });\n      }\n  \n      // Sort by code\n      lines.sort((a, b) => a.accountCode.localeCompare(b.accountCode));\n  \n      return {\n          lines,\n          totalDebit: round(grandTotalDebit),\n          totalCredit: round(grandTotalCredit),\n          asOf: data.to || new Date()\n      };\n    });\n  }\n  \n  export function getProfitAndLoss(\n    data: { from?: Date; to?: Date; metaFilter?: Record<string, any> },\n    ctx: AccountingDbContext\n  ): Promise<ProfitAndLossResult> {\n    return execute(async () => {\n      const fromDate = data.from || new Date(0); // Default to beginning of time\n      const toDate = data.to || new Date();     // Default to now\n\n      // 1. Get Income and Expense Accounts\n      const accounts = await ctx.db.collection<Account>(ACCT_COLLECTION)\n          .find(withChrStatusFilter({\n              parentGroup: { $in: ['income', 'expense'] }\n          }), { session: ctx.session })\n          .toArray();\n      \n      const accountKeys = accounts.map(a => a.key);\n      const acctMap = new Map<string, Account>(accounts.map(a => [a.key, a]));\n  \n      // 2. Aggregate Transactions for these accounts\n      const match: any = withChrStatusFilter({\n          accountKey: { $in: accountKeys },\n          voided: false,\n          datetime: { $gte: fromDate, $lte: toDate }\n      });\n\n      if (data.metaFilter) {\n        for (const [k, v] of Object.entries(data.metaFilter)) {\n            match[`meta.${k}`] = v;\n        }\n      }\n\n      const aggr = await ctx.db.collection<TransactionLine>(TX_COLLECTION).aggregate([\n          { $match: match },\n          {\n              $group: {\n                  _id: \"$accountKey\",\n                  debit: { $sum: \"$debit\" },\n                  credit: { $sum: \"$credit\" }\n              }\n          }\n      ], { session: ctx.session }).toArray();\n  \n      const incomeBreakdown: Record<string, number> = {};\n      const expenseBreakdown: Record<string, number> = {};\n      let totalIncome = 0;\n      let totalExpense = 0;\n  \n      for (const row of aggr) {\n          const acct = acctMap.get(row._id)!;\n          const net = getNetBalance(row.debit, row.credit, acct.type, acct.parentGroup);\n          \n          if (acct.parentGroup === 'income') {\n              const group = acct.group || 'General';\n              incomeBreakdown[group] = round((incomeBreakdown[group] || 0) + net);\n              totalIncome += net;\n          } else if (acct.parentGroup === 'expense') {\n              const group = acct.group || 'General';\n              expenseBreakdown[group] = round((expenseBreakdown[group] || 0) + net);\n              totalExpense += net;\n          }\n      }\n  \n      return {\n          income: round(totalIncome),\n          expense: round(totalExpense),\n          netProfit: round(totalIncome - totalExpense),\n          currency: 'USD', \n          from: fromDate,\n          to: toDate,\n          breakdown: {\n              income: incomeBreakdown,\n              expense: expenseBreakdown\n          }\n      };\n    });\n  }\n  \n  export function getBalanceSheet(\n    data: { asOf: Date },\n    ctx: AccountingDbContext\n  ): Promise<BalanceSheetResult> {\n    return execute(async () => {\n        // BS includes Asset, Liability, Equity. \n        // Note: Net Income from P&L is technically part of Equity (Retained Earnings).\n        // This simple implementation calculates explicit Equity account balances. \n        // A full system usually calculates current year earnings dynamically and adds to Equity.\n        // Here we aggregate all BS accounts. Implicitly, if P&L accounts aren't closed to Equity, \n        // BS might not balance unless we include Net Income dynamically.\n        // For this library, we assume a \"Retained Earnings\" logic is handled via journal entries \n        // or we simply report what is in the accounts.\n        \n        // HOWEVER, standard BS calculation usually implies:\n        // Assets = Liabilities + Equity + (Income - Expense)\n        \n        // Let's gather all 5 types to ensure equation holds.\n        \n        const aggr = await ctx.db.collection<TransactionLine>(TX_COLLECTION).aggregate([\n            {\n                $match: withChrStatusFilter({\n                    voided: false,\n                    datetime: { $lte: data.asOf }\n                })\n            },\n            {\n                $group: {\n                    _id: \"$accountKey\",\n                    debit: { $sum: \"$debit\" },\n                    credit: { $sum: \"$credit\" }\n                }\n            }\n        ], { session: ctx.session }).toArray();\n  \n        const accounts = await ctx.db\n            .collection<Account>(ACCT_COLLECTION)\n            .find(withChrStatusFilter({}), { session: ctx.session })\n            .toArray();\n        const acctMap = new Map<string, Account>(accounts.map(a => [a.key, a]));\n  \n        const assetsBreakdown: Record<string, number> = {};\n        const liabBreakdown: Record<string, number> = {};\n        const equityBreakdown: Record<string, number> = {};\n  \n        let totalAssets = 0;\n        let totalLiab = 0;\n        let totalEquity = 0;\n        let netIncome = 0; // Calculated from Income - Expense\n  \n        for (const row of aggr) {\n            const acct = acctMap.get(row._id);\n            if (!acct) continue;\n  \n            const net = getNetBalance(row.debit, row.credit, acct.type, acct.parentGroup);\n            const group = acct.group || 'General';\n  \n            if (acct.parentGroup === 'asset') {\n                assetsBreakdown[group] = round((assetsBreakdown[group] || 0) + net);\n                totalAssets += net;\n            } else if (acct.parentGroup === 'liability') {\n                liabBreakdown[group] = round((liabBreakdown[group] || 0) + net);\n                totalLiab += net;\n            } else if (acct.parentGroup === 'equity') {\n                equityBreakdown[group] = round((equityBreakdown[group] || 0) + net);\n                totalEquity += net;\n            } else if (acct.parentGroup === 'income') {\n                netIncome += net;\n            } else if (acct.parentGroup === 'expense') {\n                netIncome -= net; // Expenses reduce equity\n            }\n        }\n  \n        // Add Net Income to Equity (Retained Earnings bucket)\n        // We will add it to a specific key in the breakdown or just the total.\n        const retainedKey = 'Retained Earnings (Calc)';\n        equityBreakdown[retainedKey] = round((equityBreakdown[retainedKey] || 0) + netIncome);\n        totalEquity += netIncome;\n  \n        return {\n            assets: round(totalAssets),\n            liabilities: round(totalLiab),\n            equity: round(totalEquity),\n            asOf: data.asOf,\n            breakdown: {\n                assets: assetsBreakdown,\n                liabilities: liabBreakdown,\n                equity: equityBreakdown\n            }\n        };\n    });\n  }","import { AccountingDbContext, AccountSeed, Account } from '../types';\nimport { execute, withChrStatusDocument, withChrStatusFilter } from '../utils';\nimport { ObjectId } from 'mongodb';\n\nconst ACCT_COLLECTION = 'acct_accounts';\nconst JOURNAL_COLLECTION = 'acct_journals';\nconst TX_COLLECTION = 'acct_transactions';\n\nexport function ensureAccountingIndexes(\n  ctx: AccountingDbContext\n): Promise<string[]> {\n  return execute(async () => {\n    const p1 = ctx.db.collection(ACCT_COLLECTION).createIndexes([\n      { key: { key: 1 }, unique: true },\n      { key: { code: 1 }, unique: true },\n      { key: { type: 1 } },\n      { key: { parentGroup: 1 } },\n      { key: { chrStatus: 1 } },\n    ], { session: ctx.session });\n\n    const p2 = ctx.db.collection(JOURNAL_COLLECTION).createIndexes([\n      { key: { datetime: 1 } },\n      { key: { referenceType: 1, referenceId: 1 } },\n      { key: { chrStatus: 1 } },\n    ], { session: ctx.session });\n\n    const p3 = ctx.db.collection(TX_COLLECTION).createIndexes([\n      { key: { accountKey: 1, datetime: 1 } }, // For getting balance/ledger\n      { key: { journalId: 1 } }, // For getting journal details\n      { key: { \"meta.customerId\": 1 }, sparse: true }, // Example loose index\n      { key: { chrStatus: 1 } },\n    ], { session: ctx.session });\n\n    const results = await Promise.all([p1, p2, p3]);\n    return results.flat();\n  });\n}\n\nexport function seedAccounts(\n  accounts: AccountSeed[],\n  ctx: AccountingDbContext\n): Promise<Account[]> {\n  return execute(async () => {\n    // We do bulk upserts to ensure idempotency\n    const ops = accounts.map(acct => ({\n        updateOne: {\n            filter: { key: acct.key },\n            update: {\n                $setOnInsert: {\n                    ...withChrStatusDocument({\n                        ...acct,\n                        _id: new ObjectId(),\n                        isActive: true,\n                        createdAt: new Date(),\n                        updatedAt: new Date()\n                    })\n                }\n            },\n            upsert: true\n        }\n    }));\n\n    if (ops.length > 0) {\n        await ctx.db.collection(ACCT_COLLECTION).bulkWrite(ops, { session: ctx.session });\n    }\n    \n    // Return the actual docs\n    return ctx.db.collection<Account>(ACCT_COLLECTION)\n        .find(withChrStatusFilter({ key: { $in: accounts.map(a => a.key) } }), { session: ctx.session })\n        .toArray();\n  });\n}"]}